<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"  http-equiv="content-type" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <title>SOCI - backends</title>
</head>

<body>
<p class="banner">SOCI - The C++ Database Access Library</p>

<h2>Backends reference</h2>

<p>This part of the documentation is provided for those who want to
write (and contribute!) their own backends. It is anyway recommended
that authors of new backend see the code of some existing backend for
hints on how things are really done.</p>

<p>The backend interface is a set of base classes that the actual backends
are supposed to specialize. The main SOCI interface uses only the
interface and respecting the protocol (for example, the order of
function calls) described here. Note that both the interface and the
protocol were initially designed with the Oracle database in mind,
which means
that whereas it is quite natural with respect to the way Oracle API
(OCI) works, it might impose some implementation burden on other
backends, where things are done differently and therefore have to be
adjusted, cached, converted, etc.</p>

<p>The interface to the common SOCI interface is defined in the <code>core/soci-backend.h</code>
header file. This file is dissected below.</p>

<p>All names are defined in either <code>SOCI</code> or <code>SOCI::details</code>
namespace.</p>

<pre class="example">
// data types, as seen by the user
enum eDataType { eString, eChar, eDate, eDouble, eInteger,
                 eUnsignedLong };

// the enum type for indicator variables
enum eIndicator { eOK, eNoData, eNull, eTruncated };

// data types, as used to describe exchange format
enum eExchangeType { eXChar, eXCString, eXStdString, eXShort, eXInteger,
                     eXUnsignedLong, eXDouble, eXStdTm, eXStatement,
                     eXRowID, eXBLOB };

struct CStringDescriptor
{
    CStringDescriptor(char *str, std::size_t bufSize)
        : str_(str), bufSize_(bufSize) {}

    char *str_;
    std::size_t bufSize_;
};

class SOCIError : public std::runtime_error
{
public:
    SOCIError(std::string const &amp; msg, int errNum = 0);

    int errNum_;
};
</pre>

<p>The <code>eDataType</code> enumeration type defines all types that
form the core type support for SOCI. The enum itself can be used by
clients when dealing with dynamic rowset description.</p>

<p>The <code>eIndicator</code> enumeration type defines all recognized <i>states</i> of data. The <code>eTruncated</code>
state is provided for the case where the string is retrieved from the
database into the char buffer that is not long enough to hold the whole
value.</p>

<p>The <code>eExchangeType</code> enumeration type defines all possible
types that can be used with the <code>into</code> and <code>use</code>
elements.</p>

<p>The <code>CStringDescriptor</code> is a helper class that allows to
store the address of <code>char</code> buffer together with its size.
The objects of this class are passed to the backend when the <code>eXCString</code>
type is involved.</p>

<p>The <code>SOCIError</code> class is an exception type used for
database-related (and
also usage-related) errors. The backends should throw exceptions of
this or derived type only.</p>

<pre class="example">
class StandardIntoTypeBackEnd
{
public:
    virtual ~StandardIntoTypeBackEnd() {}

    virtual void defineByPos(int &amp;position,
        void *data, eExchangeType type) = 0;

    virtual void preFetch() = 0;
    virtual void postFetch(bool gotData, bool calledFromFetch,
        eIndicator *ind) = 0;

    virtual void cleanUp() = 0;
};
</pre>

<p>The <code>StandardIntoTypeBackEnd</code> class implements the dynamic
interactions with the simple (non-bulk) <code>into</code> elements.
The objects of this class (or, rather, of the derived class implemented
by the actual backend) are created by the <code>Statement</code>
object when the <code>into</code> element is bound - in terms of
lifetime management, <code>Statement</code> is the master of this
class.</p>
<ul>
  <li><code>defineByPos</code> - Called when the <code>into</code>
element is bound, once and before the statement is executed. The <code>data</code>
pointer points to the variable used for <code>into</code> element (or
to the <code>CStringDescriptor</code> object, which is artificially
created when the plain <code>char</code> buffer is used for data
exchange). The <code>position</code> parameter is a "column number",
assigned by
the library. The backend should increase this parameter, according to
the number of fields actually taken (usually 1).</li>
  <li><code>preFetch</code> - Called before each row is fetched.</li>
  <li><code>postFetch</code> - Called after each row is fetched. The <code>gotData</code>
parameter is <code>true</code> if the fetch operation really retrieved
some data and <code>false</code> otherwise; <code>calledFromFetch</code>
is <code>true</code> when the call is from the fetch operation and <code>false</code>
if it is from the execute operation (this is also the case for simple,
one-time queries). In particular, <code>(calledFromFetch &amp;&amp;
!gotData)</code> indicates that there is an end-of-rowset condition. <code>ind</code>
points to the indicator provided by the user, or is <code>NULL</code>,
if there is no indicator.</li>
  <li><code>cleanUp</code> - Called once when the statement is
destroyed.</li>
</ul>

<p>The intended use of <code>preFetch</code> and <code>postFetch</code>
functions is to manage any internal buffer and/or data conversion for
each value retrieved from the database. If the given server supports
binary data transmission and the data format for the given type agrees
with what is used on the client machine, then these two functions need
not do anything; otherwise buffer management and data conversions
should go there.</p>

<pre class="example">
class VectorIntoTypeBackEnd
{
public:
    virtual ~VectorIntoTypeBackEnd() {}

    virtual void defineByPos(int &amp;position,
        void *data, eExchangeType type) = 0;

    virtual void preFetch() = 0;
    virtual void postFetch(bool gotData, eIndicator *ind) = 0;

    virtual void resize(std::size_t sz) = 0;
    virtual std::size_t size() = 0;

    virtual void cleanUp() = 0;
};
</pre>

<p>The <code>VectorIntoTypeBackEnd</code> has similar structure and
purpose as the previous one, but is used for vectors (bulk data
retrieval).</p>

<p>The <code>data</code> pointer points to the variable of type <code>std::vector&lt;T&gt;</code>
(<i>not</i> to its internal buffer), <code>resize</code>
is supposed to really resize the user-provided vector and <code>size</code>
is supposed to return the current size of this vector.
The important difference with regard to the previous class is that <code>ind</code>
points (if not <code>NULL</code>) to the beginning of the <i>array</i> of indicators. The backend
should fill this array according to the actual state of the retrieved
data.</p>

<pre class="example">
class StandardUseTypeBackEnd
{
public:
    virtual ~StandardUseTypeBackEnd() {}

    virtual void bindByPos(int &amp;position,
        void *data, eExchangeType type) = 0;
    virtual void bindByName(std::string const &amp;name,
        void *data, eExchangeType type) = 0;

    virtual void preUse(eIndicator const *ind) = 0;
    virtual void postUse(bool gotData, eIndicator *ind) = 0;

    virtual void cleanUp() = 0;
};
</pre>

<p>The <code>StandardUseTypeBackEnd</code> implements the interactions
with the simple (non-bulk) <code>use</code> elements, created and
destroyed by the <code>Statement</code> object.</p>
<ul>
  <li><code>bindByPos</code> - Called for each <code>use</code>
element, once and before the statement is executed - for those <code>use</code>
elements that do not provide explicit names for parameter binding. The
meaning of parameters is same as in previous classes.</li>
  <li><code>bindByName</code> - Called for those <code>use</code>
elements that provide the explicit name.</li>
  <li><code>preUse</code> - Called before the data is transmitted to
the server (this means before the statement is executed, which can
happen many times for the prepared statement). <code>ind</code> points
to the indicator provided by the user (or is <code>NULL</code>).</li>
  <li><code>postUse</code> - Called after statement execution. <code>gotData</code>
and <code>ind</code> have the same meaning as in <code>StandardIntoTypeBackEnd::postFetch</code>,
and this can be used by those backends whose respective servers support
two-way data exchange (like in/out parameters in stored procedures).</li>
</ul>

<p>The intended use fot <code>preUse</code> and <code>postUse</code>
methods is to manage any internal buffers and/or data conversion. They
can be called many times with the same statement.</p>

<pre class="example">
class VectorUseTypeBackEnd
{
public:
    virtual ~VectorUseTypeBackEnd() {}

    virtual void bindByPos(int &amp;position,
        void *data, eExchangeType type) = 0;
    virtual void bindByName(std::string const &amp;name,
        void *data, eExchangeType type) = 0;

    virtual void preUse(eIndicator const *ind) = 0;

    virtual std::size_t size() = 0;

    virtual void cleanUp() = 0;
};
</pre>

<p>Objects of this type (or rather of type derived from this one) are used
to implement interactions with user-provided vector (bulk) <code>use</code>
elements and are managed by the <code>Statement</code> object.
The <code>data</code> pointer points to the whole vector object
provided by the user (<i>not</i> to
its internal buffer); <code>ind</code> points to the beginning of the
array of indicators (or is <code>NULL</code>). The meaning of this
interface is analogous to those presented above.</p>

<pre class="example">
class StatementBackEnd
{
public:
    virtual ~StatementBackEnd() {}

    virtual void alloc() = 0;
    virtual void cleanUp() = 0;
    virtual void prepare(std::string const &amp;query) = 0;

    enum execFetchResult { eSuccess, eNoData };
    virtual execFetchResult execute(int number) = 0;
    virtual execFetchResult fetch(int number) = 0;

    virtual int getNumberOfRows() = 0;

    virtual std::string rewriteForProcedureCall(std::string const &amp;query) = 0;

    virtual int prepareForDescribe() = 0;
    virtual void describeColumn(int colNum, eDataType &amp;dtype,
        std::string &amp;columnName, int &amp;size, int &amp;precision, int &amp;scale,
        bool &amp;nullOk) = 0;

    virtual StandardIntoTypeBackEnd * makeIntoTypeBackEnd() = 0;
    virtual StandardUseTypeBackEnd * makeUseTypeBackEnd() = 0;
    virtual VectorIntoTypeBackEnd * makeVectorIntoTypeBackEnd() = 0;
    virtual VectorUseTypeBackEnd * makeVectorUseTypeBackEnd() = 0;
};
</pre>

<p>The <code>StatementBackEnd</code> type implements the internals of the
<code>Statement</code> objects (in fact, it is a basic Strategy design
pattern). The objects of this class are created by the <code>Session</code>
object.</p>
<ul>
  <li><code>alloc</code> - Called once to allocate everything that is
needed for the statement to work correctly.</li>
  <li><code>cleanUp</code> - Supposed to clean up the resources, called
once.</li>
  <li><code>prepare</code> - Called once with the text of the SQL
query. For servers that support explicit query preparation, this is the
place to do it.</li>
  <li><code>execute</code> - Called to execute the query; if number is
zero, the intent is not to exchange data with the user-provided objects
(<code>into</code> and <code>use</code> elements); positive values
mean the number of rows to exchange (more than 1 is used only for bulk
operations).</li>
  <li><code>fetch</code> - Called to fetch next bunch of rows; number
is positive and determines the requested number of rows (more than 1 is
used only for bulk operations).</li>
  <li><code>getNumberOfRows</code> - Called to determine the actual
number of rows retrieved by the previous call to <code>execute</code>
or <code>fetch</code>.</li>
  <li><code>rewriteForProcedureCall</code> - Used when the <code>Procedure</code>
is used instead of <code>Statement</code>, to call the stored
procedure. This function should rewrite the SQL query (if necessary) to
the form that will allow to execute the given procedure.
  </li>
  <li><code>prepareForDescribe</code> - Called once when the <code>into</code>
element is used with the <code>Row</code> type, which means that
dynamic rowset description should be performed. It is supposed to do
whatever is needed to later describe the column properties and should
return the number of columns.</li>
  <li><code>describeColumn</code> - Called once for each column (column
numbers - <code>colNum</code> - start from 1), should fill its
parameters according to the column properties.</li>
  <li><code>makeIntoTypeBackEnd</code>, <code>makeUseTypeBackEnd</code>,
    <code>makeVectorIntoTypeBackEnd</code>, <code>makeVectorUseTypeBackEnd</code>
- Called once for each <code>into</code> or <code>use</code> element,
to create the objects of appropriate classes (described above).</li>
</ul>

<p>Notes:</p>
<ol>
  <li>Whether the query is executed using the simple one-time syntax or
is prepared, the <code>alloc</code>, <code>prepare</code> and <code>execute</code>
functions are always called, in this order.</li>
  <li>All <code>into</code> and <code>use</code> elements are bound
(their <code>defineByPos</code> or <code>bindByPos</code>/<code>bindByName</code>
functions are called) <i>between</i>
statement preparation and execution.
  </li>
</ol>

<pre class="example">
class RowIDBackEnd
{
public:
    virtual ~RowIDBackEnd() {}
};
</pre>

<p>The <code>RowIDBackEnd</code> class is a hook for the backends to
provide their own state for the row identifier. It has no functions,
since the only portable interaction with the row identifier object is
to use it with <code>into</code> and <code>use</code> elements.</p>

<pre class="example">
class BLOBBackEnd
{
public:
    virtual ~BLOBBackEnd() {}

    virtual std::size_t getLen() = 0;
    virtual std::size_t read(std::size_t offset, char *buf,
        std::size_t toRead) = 0;
    virtual std::size_t write(std::size_t offset, char const *buf,
        std::size_t toWrite) = 0;
    virtual std::size_t append(char const *buf, std::size_t toWrite) = 0;
    virtual void trim(std::size_t newLen) = 0;
};
</pre>

<p>The <code>BLOBBackEnd</code> interface provides the entry points for
the <code>BLOB</code> methods.</p>

<pre class="example">
class SessionBackEnd
{
public:
    virtual ~SessionBackEnd() {}

    virtual void begin() = 0;
    virtual void commit() = 0;
    virtual void rollback() = 0;

    virtual StatementBackEnd * makeStatementBackEnd() = 0;
    virtual RowIDBackEnd * makeRowIDBackEnd() = 0;
    virtual BLOBBackEnd * makeBLOBBackEnd() = 0;
};
</pre>

<p>The object of the class derived from SessionBackEnd implements the
internals of the Session object.</p>
<ul>
  <li><code>begin</code>, <code>commit</code>, <code>rollback</code>
- Forward-called when the same functions of <code>Session</code> are
called by user.</li>
  <li><code>makeStatementBackEnd</code>, <code>makeRowIDBackEnd</code>,
    <code>makeBLOBBackEnd</code> - Called to create respective
implementations for the <code>Statement</code>, <code>RowID</code>
and <code>BLOB</code> classes.
  </li>
</ul>

<pre class="example">
struct BackEndFactory
{
    virtual SessionBackEnd * makeSession(
        std::string const &amp;connectString) const = 0;
};
</pre>

<p>The <code>BackEndFactory</code> is a base class for backend-provided
factory class that is able to create valid sessions. The <code>connectString</code>
parameter passed to <code>makeSession</code> is provided here by the <code>Session</code>
constructor.</p>

<p>The actual backend factory object is supposed to be provided by the
backend implementation and declared in its header file.</p>

<p>The following example is taken from <code>soci-postgresql.h</code>,
which declares entities of the PostgreSQL backend:</p>

<pre class="example">
// concrete backend factory for PostgreSQL
struct PostgreSQLBackEndFactory : BackEndFactory
{
    virtual PostgreSQLSessionBackEnd * makeSession(
        std::string const &amp;connectString) const;
};

// globally visible factory object
extern PostgreSQLBackEndFactory const postgresql;
</pre>

<p>With the above declarations, it is enough to pass the <code>postgresql</code>
factory name to the constructor of the <code>Session</code> object,
which will use this factory to create concrete implementations for any
other objects that
are needed, with the help of appropriate <code>makeXYZ</code>
functions.</p>

<p>Note that the backend source code is placed in the <code>backends/<i>name</i></code> directory (for example,
<code>backends/oracle</code>) and the test driver is in <code>backends/<i>name</i>/test</code>. There is also <code>backends/empty</code>
directory provided as a skeleton for development of new backends and
their tests. It is
recommended that all backends respect naming conventions by just
appending their name to the base-class names. The backend name used for
the global factory object should clearly identify the given
database engine, like <code>oracle</code>, <code>postgresql</code>, <code>mysql</code>,
and so on.</p>

<table class="foot-links" border="0" cellpadding="2" cellspacing="2">
  <tr>
    <td class="foot-link-left">
      <a href="reference.html">Previous (Client reference)</a>
    </td>
    <td class="foot-link-right">
      <a href="rationale.html">Next (Rationale FAQ)</a>
    </td>
  </tr>
</table>

<p class="copyright">Copyright &copy; 2004-2006 Maciej Sobczak, Stephen Hutton</p>
</body>
</html>
